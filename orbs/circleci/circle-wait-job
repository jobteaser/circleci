#!/usr/bin/env ruby

require("optparse")
require("net/http")
require("json")

class CLI
  attr_reader(:token, :organization, :project, :job, :branch, :interval, :vcs, :build_number)

  def initialize
    @branch = ENV["CIRCLE_BRANCH"]
    @interval = "60"
    @vcs = "github"
    @build_number = ENV["CIRCLE_BUILD_NUM"]
    @token = ENV["CIRCLE_TOKEN"]
    @current_job = ENV["CIRCLE_JOB"]
    @job = ENV["CIRCLE_JOB"]
    @organization = ENV["CIRCLE_PROJECT_USERNAME"]
    @project = ENV["CIRCLE_PROJECT_REPONAME"]
  end

  def parse(args)
    OptionParser.new do |parser|
      define_options!(parser)
      parser.parse!(args)
    end

    must_not_empty("branch", @branch)
    must_not_empty("interval", @interval)
    must_not_empty("vcs", @vcs)
    must_not_empty("current-build-number", @build_number)
    must_not_empty("token", @token)
    must_not_empty("job", @job)
    must_not_empty("organization", @organization)
    must_not_empty("project", @project)

    self
  end

  private

  def must_not_empty(key, value)
    if value.to_s.empty?
      raise(ArgumentError, "the #{key} is missing or empty")
    end
  end

  def define_options!(parser)
    parser.banner = "Usage: circleci-wait-job OPTIONS"
    parser.separator("")
    parser.separator("OPTIONS")
    parser.separator("")

    parser.on("-t=VALUE", "--token=VALUE", "the circleci api token") { |value| @token = value }
    parser.on("-o=VALUE", "--organization=VALUE", "the circleci organization name") { |value| @organization = value }
    parser.on("-p=VALUE", "--project=VALUE", "the circleci project name") { |value| @project = value }
    parser.on("-j=VALUE", "--job=VALUE", "the circleci job name") { |value| @job = value }
    parser.on("-b=VALUE", "--branch=VALUE", "the circleci branch") { |value| @branch = value }
    parser.on("-i=VALUE", "--interval=VALUE", "the wait time between pooling") { |value| @interval = value }
    parser.on("--vcs=VALUE", "the version control system (default: github)") { |value| @vcs = value }
    parser.on("--current-build-number=VALUE", "the current circleci build number") { |value| @build_number = value }

    parser.on_tail("-h", "--help", "print help and exit") do
      puts(parser)
      exit(0)
    end

    parser.on_tail("--version", "print version and exit") do
      puts("v0.0.1")
      exit(0)
    end
  end
end

cli = CLI.new

begin
  options = cli.parse(ARGV)
rescue ArgumentError => e
  puts(e.message)
  exit(1)
end

uri = URI::HTTPS.build(host: "circleci.com",
                       path: File.join("/",
                                       "api",
                                       "v1.1",
                                       "project",
                                       options.vcs.to_s,
                                       options.organization.to_s,
                                       options.project.to_s,
                                       "tree",
                                       options.branch.to_s),
                       query: URI.encode_www_form({"circle-token" => options.token.to_s,
                                                   "shallow" => true,
                                                   "filter" => "running"}))


def other_job_is_running?(uri, job, build_num)
  response = Net::HTTP.get(uri)
  builds = JSON.parse(response)

  # Check if another identical job (most likely a production deployment job) is running for another build
  has_concurrent_job = builds.any? do |build|
    is_concurrent_build = build.dig("workflows", "job_name").to_s == job && build["build_num"] != build_num
    puts("Checking #{build.build_url}...")
    if is_concurrent_build
      puts("Found concurrent build: #{build.build_url}")
    else
      puts("Not a concurrent build.")
    end
    is_concurrent_build
  end

  puts(has_concurrent_job ? "Found concurrent job" : "No concurrent job found")

  if has_concurrent_job
    return true
  else
    # We know that no "production deployment job" is running but there is a possibility that 2 builds are
    # running the same job as the current one simultaneously. This means that both builds could enter a
    # "production deployment job" at the same time after the present job is done. We must avoid it.
    # Check if another other build is running the same job as the current one (most likely a
    # concurrent_build_management job).
    # Iterate on builds and regroup builds by job name in a dict:
    # Ex: { concurrent_build_management: [build1, build2], test_js: [build3], ...}
    builds_by_job_name = Hash.new
    builds.each_entry do |build|
      build_job_name = build.dig("workflows", "job_name").to_s
      builds_by_job_name[build_job_name] = builds_by_job_name[build_job_name] || []
      builds_by_job_name[build_job_name].push(build)
    end
    # Look for builds that have a job name == @current_job since the present script is expected to
    # be called for a job whose concurrent run is not allowed
    concurrent_builds_for_current_job = builds_by_job_name[@current_job]

    # Iterate on those builds and retrieve git logs for each
    concurrent_builds_for_current_job.each_entry do |build|
      print "Build running job #{@current_job} : #{build.build_url}"
      print `git log --pretty=format:"%H" -2 #{build.vcs_revision} | jo -a`
    end
    # send above response to: builds = JSON.parse(response)

    # Now, the present build must determine if it is the oldest build running (regarding its git history)
    # - if yes, let it continue (return false)
    # - if no, put it in pause (return true)
    # An algo:
    # Use HEAD commit date
    # Another algo:
    # If count of build === 1, let it continue
    # else for each "git log build", take the HEAD and if it is present in another git log, add 1 to a dict
    # git_heads_occurences {<head>: count_of_occurence}.
    # After all that, find the entry in dict git_heads_occurences with the higher count. If the head found
    # is the one of the current build, it means it's the older build to we can let it pass (return false),
    # if not return true
  end
end

puts("10")
puts("Check no other #{options.job} for #{options.branch} branch is running")

while other_job_is_running?(uri, options.job.to_s, options.build_number.to_i) do
  puts("Another #{options.job} for #{options.branch} branch already running, check again in #{options.interval} seconds.")
  sleep(options.interval.to_i)
end
